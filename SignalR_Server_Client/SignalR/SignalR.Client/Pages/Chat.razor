@page "/chat"
@using SignalR.Client.Services.Interfaces
@inject IChatService ChatService
@inject IJSRuntime JsRuntime

@* 
    Comment Section: StateHasChanged, ScrollLogToBottom, and Related Patterns

    1. StateHasChanged()
    - Use Case: Notifies Blazor that the component's state has changed, triggering a synchronous render on the current thread.
    - When Used: In action methods (e.g., Leave(), LeaveGroup()) after updating state (e.g., _statusMessages, _currentUser) to refresh 
        the UI immediately.
    - Why: Simple, synchronous, and safe in WebAssembly mode (single-threaded) when called post-await or in user-triggered 
        events (e.g., button clicks). Avoids overhead of InvokeAsync when already on the UI thread.

    2. ScrollLogToBottom()
    - Use Case: Scrolls the activity log (<div class="log-list">) to the bottom using JS interop (JSRuntime.InvokeVoidAsync).
    - When Used: In action methods (e.g., LeaveGroup()) after state updates to ensure the latest log entry is visible.
    - Why: Async method due to JS interop; must be awaited to ensure scrolling happens after the UI reflects the new state, 
        avoiding race conditions where scroll occurs before render.

    3. await InvokeAsync(StateHasChanged)
    - Use Case: Asynchronously queues a render on the UI thread (synchronization context), ensuring thread safety for SignalR event handlers.
    - When Used: In OnInitializedAsync event handlers (e.g., OnMessageReceived, OnUserJoined) triggered by ChatService SignalR events.
    - Why: SignalR events might fire on background threads (hub connection thread), even in WebAssembly (less common but possible). 
        InvokeAsync ensures UI updates are marshaled to the renderer’s thread, making it robust for potential InteractiveServer mode 
        use (multithreaded circuit).

    4. await ScrollLogToBottom()
    - Use Case: Ensures the JS interop scroll completes before proceeding, used in action methods or deferred via OnAfterRenderAsync.
    - When Used: In LeaveGroup() after StateHasChanged() to scroll post-render, and in OnAfterRenderAsync when deferred from event handlers.
    - Why: Awaited in action methods to maintain order (render, then scroll). Deferred to OnAfterRenderAsync in event handlers to avoid 
        JS interop during prerendering (SSR), which lacks a browser context.

    5. _needsScroll (private bool field)
    - Use Case: Flags when the activity log needs scrolling, set in SignalR event handlers and checked in OnAfterRenderAsync.
    - When Used: In OnInitializedAsync event handlers (e.g., OnUserJoined, OnPrivateMessageReceived) to defer scrolling until post-render.
    - Why: Prevents JS interop errors during prerendering (SSR) when the log-list element isn’t in the DOM yet. Combined with isJoined 
        check in OnAfterRenderAsync, ensures scrolling only happens when the log is visible (isJoined = true).
*@

<div class="chat-container">
    <h3>Chat Room</h3>
    @if (ChatService == null)
    {
        <p>Error: ChatService not available. Please refresh or contact support.</p>
    }
    else
    {
        <p>Debug: IsConnected = @ChatService.IsConnected, CurrentUser = "@_currentUser", IsJoined = @_isJoined</p>
        @if (!ChatService.IsConnected)
        {
            <p class="status">Connecting to chat... <span class="spinner"></span></p>
        }
        else if (!_isJoined)
        {
            <div class="join-section">
                <input @bind="_currentUser" @bind:event="oninput" placeholder="Enter your name" class="input-field" />
                <select @bind="_selectedLanguage" class="input-field" style="margin-left: 10px;">
                    <option value="en">English</option>
                    <option value="es">Spanish</option>
                    <option value="fr">French</option>
                    <option value="de">German</option>
                    <option value="zh">Chinese</option>
                    <option value="ar">Arabic</option>
                    <option value="ru">Russian</option>
                    @* <option value="hi">Hindi</option> *@
                </select>
                <button @onclick="Join" class="btn btn-primary">Join Chat</button>
            </div>
        }
        else
        {
            <div class="user-info">
                <p>Logged in as: <strong>@_currentUser</strong> (Language: @_selectedLanguage, ID: @ChatService.ConnectionId)</p>
                <button @onclick="Leave" class="btn btn-danger">Leave Chat</button>
            </div>

            <!-- General Chat Section -->
            <div class="chat-section">
                <h4>General Chat</h4>
                <div class="message-list">
                    @foreach (var msg in _messages)
                    {
                        <p>@msg</p>
                    }
                </div>
                <div class="input-group">
                    <input @bind="_message" @bind:event="oninput" placeholder="Type a message" class="input-field" />
                    <button @onclick="Send" class="btn btn-primary">Send</button>
                </div>
            </div>

            <!-- Group Chats Section -->
            <div class="chat-section">
                <h4>Group Chats</h4>
                <div class="message-list">
                    @foreach (var msg in _messages.Where(m => m.Contains("[Group")))
                    {
                        <p>@msg</p>
                    }
                </div>
                @if (ChatService.JoinedGroups.Any())
                {
                    <div class="group-select">
                        <label>Select group to send to:</label>
                        <select @bind="_selectedGroup" class="input-field">
                            @foreach (var group in ChatService.JoinedGroups)
                            {
                                <option value="@group">@group</option>
                            }
                        </select>
                    </div>
                }
                <div class="input-group">
                    <input @bind="_groupMessage" @bind:event="oninput" placeholder="Group message" class="input-field" />
                    <button @onclick="SendGroup" class="btn btn-primary" disabled="@(string.IsNullOrEmpty(_selectedGroup))">Send to Group</button>
                </div>
            </div>

            <!-- Private Chats Section -->
            <div class="chat-section">
                <h4>Private Chats</h4>
                <div class="message-list">
                    @foreach (var msg in _privateMessages)
                    {
                        <p>@msg</p>
                    }
                </div>
                @if (_onlineUsers.Any(u => u != _currentUser))
                {
                    <div class="user-select">
                        <label>Select user to message:</label>
                        <select @bind="_selectedUser" @bind:event="onchange" class="input-field">
                            <option value="">Select User</option>
                            @foreach (var user in _onlineUsers.Where(u => u != _currentUser).Distinct().OrderBy(u => u))
                            {
                                <option value="@user">@user</option>
                            }
                        </select>
                    </div>
                }
                <div class="input-group">
                    <input @bind="_privateMessage" @bind:event="oninput" placeholder="Private message" class="input-field" />
                    <button @onclick="SendPrivate" class="btn btn-primary" disabled="@(string.IsNullOrEmpty(_selectedUser))">Send Private</button>
                </div>
            </div>

            <!-- Join/Leave Group Section -->
            <div class="group-join-section">
                <h4>Join/Leave Group</h4>
                <div class="group-controls">
                    <input @bind="_groupName" @bind:event="oninput" placeholder="Group name" class="input-field" />
                    <button @onclick="JoinGroup" class="btn btn-success">Join</button>
                    <button @onclick="LeaveGroup" class="btn btn-warning">Leave</button>
                </div>
                <p>Joined groups: @(ChatService.JoinedGroups.Any() ? string.Join(", ", ChatService.JoinedGroups) : "None")</p>
            </div>

            <!-- Activity Log Section -->
            <div class="log-window">
                <h4>Activity Log</h4>
                <div class="log-list" @ref="_logList">
                    @foreach (var entry in _statusMessages)
                    {
                        <p @key="entry.Timestamp.Ticks" class="@GetLogClass(entry.Message)">
                            @entry.Timestamp.ToString("HH:mm:ss") - @entry.Message
                        </p>
                    }
                </div>
            </div>
        }
    }
</div>

<script>
    window.scrollToBottom = (element) => {
        element.scrollTop = element.scrollHeight;
    };
</script>

@code {
    // Private fields for component state management
    // _currentUser: Stores the user's chosen name
    // _message, _groupMessage, _privateMessage: Input fields for different message types
    // _groupName: Input for group names in join/leave operations
    // _selectedGroup, _selectedUser: Selected values for group/private messaging
    // _selectedLanguage: User's chosen native language code (e.g., "en" for English)
    // _messages, _privateMessages: Lists to store received messages for display
    // _onlineUsers: List of currently online users
    // _statusMessages: Log entries for activity tracking
    // _isJoined: Flag indicating if the user has joined the chat
    // _logList: Reference to the log DOM element for scrolling
    // _needsScroll: Flag to trigger scrolling after state changes
    private string _currentUser = "";
    private string _message = "";
    private string _groupName = "";
    private string _groupMessage = "";
    private string _privateMessage = "";
    private string? _selectedGroup = null;
    private string? _selectedUser = null;
    private string? _selectedLanguage = "en"; // Default to English; can be expanded with more options
    private readonly List<string> _messages = [];
    private readonly List<string> _privateMessages = [];
    private List<string> _onlineUsers = new();
    private readonly List<StatusEntry> _statusMessages = [];
    private bool _isJoined = false;
    private ElementReference _logList;
    private bool _needsScroll = false;

    // Nested class for status log entries
    // Timestamp: Records when the entry was created
    // Message: The log message content
    private class StatusEntry(string message)
    {
        public DateTime Timestamp { get; set; } = DateTime.Now;
        public string Message { get; set; } = message;
    }

    // Lifecycle method: Initializes the component and sets up SignalR event handlers
    // Maintenance Note: Ensure all event handlers are properly unsubscribed in Dispose if needed for memory management
    protected override async Task OnInitializedAsync()
    {
        if (ChatService == null)
        {
            Console.WriteLine("ChatService is null on initialization!");
            _statusMessages.Add(new StatusEntry("Error: ChatService not injected"));
            StateHasChanged();
            return;
        }

        Console.WriteLine("Chat page initialized, starting SignalR connection...");
        try
        {
            await ChatService.StartConnectionAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to start SignalR connection: {ex.Message}");
            _statusMessages.Add(new StatusEntry($"Error starting connection: {ex.Message}"));
            StateHasChanged();
        }

        // Event handler for general messages
        // Adds message to list and triggers UI update and scroll
        ChatService.OnMessageReceived += async (user, msg) =>
        {
            _messages.Add($"[General] {user}: {msg}");
            Console.WriteLine($"General message added: [General] {user}: {msg}");
            await InvokeAsync(StateHasChanged);
            _needsScroll = true;
        };

        // Event handler for group messages
        // Parses and formats the message, adds to list if in joined group
        ChatService.OnGroupMessageReceived += async (user, msg) =>
        {
            var parts = msg.Split('|', 2);
            if (parts.Length != 2) return;

            var groupName = parts[0];
            var messageText = parts[1];

            if (!ChatService.JoinedGroups.Contains(groupName)) return;

            var formattedMsg = $"[Group:{groupName}] {user}: {messageText}";
            _messages.Add(formattedMsg);
            Console.WriteLine($"Group message added: {formattedMsg}");
            await InvokeAsync(StateHasChanged);
            _needsScroll = true;
        };

        // Event handler for user join notifications
        ChatService.OnUserJoined += async (user) =>
        {
            _statusMessages.Add(new StatusEntry($"{user} joined the chat"));
            await InvokeAsync(StateHasChanged);
            _needsScroll = true;
        };

        // Event handler for user leave notifications
        ChatService.OnUserLeft += async (user) =>
        {
            _statusMessages.Add(new StatusEntry($"{user} left the chat"));
            await InvokeAsync(StateHasChanged);
            _needsScroll = true;
        };

        // Event handler for online user list updates
        // Resets selected user if they leave
        ChatService.OnUserListUpdated += async (users) =>
        {
            _onlineUsers = users;
            if (_selectedUser != null && !_onlineUsers.Contains(_selectedUser))
            {
                _selectedUser = null; // Reset only if selected user leaves
            }
            await InvokeAsync(StateHasChanged);
        };

        // Event handler for group-related status messages
        ChatService.OnGroupMessage += async (msg) =>
        {
            _statusMessages.Add(new StatusEntry(msg));
            await InvokeAsync(StateHasChanged);
            _needsScroll = true;
        };

        // Event handler for connection established
        ChatService.OnConnected += async () =>
        {
            _statusMessages.Add(new StatusEntry("Connected to the server"));
            await InvokeAsync(StateHasChanged);
            _needsScroll = true;
        };

        // Event handler for disconnection
        ChatService.OnDisconnected += async () =>
        {
            _statusMessages.Add(new StatusEntry("Disconnected from the server"));
            _onlineUsers.Clear();
            _isJoined = false;
            await InvokeAsync(StateHasChanged);
            _needsScroll = true;
        };

        // Event handler for reconnection attempt
        ChatService.OnReconnecting += async () =>
        {
            _statusMessages.Add(new StatusEntry("Reconnecting..."));
            await InvokeAsync(StateHasChanged);
            _needsScroll = true;
        };

        // Event handler for successful reconnection
        ChatService.OnReconnected += async () =>
        {
            _statusMessages.Add(new StatusEntry("Reconnected!"));
            _selectedGroup = null;
            _selectedUser = null;
            await InvokeAsync(StateHasChanged);
            _needsScroll = true;
        };

        // Event handler for errors
        ChatService.OnError += async (error) =>
        {
            _statusMessages.Add(new StatusEntry($"Error: {error}"));
            await InvokeAsync(StateHasChanged);
            _needsScroll = true;
        };

        // Event handler for private messages
        // Adds to private messages list and status log
        ChatService.OnPrivateMessageReceived += async (fromUser, msg) =>
        {
            if (fromUser != _currentUser)
            {
                _privateMessages.Add($"[Private] {fromUser}: {msg}");
            }
            _statusMessages.Add(new StatusEntry($"Private message from {fromUser}: {msg}"));
            Console.WriteLine($"Private message received: [Private] {fromUser} to {_currentUser}: {msg}");
            await InvokeAsync(StateHasChanged);
            _needsScroll = true;
        };
    }

    // Lifecycle method: Handles post-render logic, such as scrolling the log
    // Maintenance Note: Use _needsScroll flag to defer JS interop until after render, avoiding DOM not ready errors
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        Console.WriteLine($"Chat.razor rendered, firstRender: {firstRender}");
        if (_needsScroll && ChatService != null && _isJoined)
        {
            await ScrollLogToBottom();
            _needsScroll = false;
        }
        await base.OnAfterRenderAsync(firstRender);
    }

    // JS interop method: Scrolls the log element to the bottom
    // Maintenance Note: Ensure the script tag with window.scrollToBottom is present in the component
    private async Task ScrollLogToBottom()
    {
        await JsRuntime.InvokeVoidAsync("scrollToBottom", _logList);
    }

    // Utility method: Determines CSS class for log entries based on content
    // Maintenance Note: Expand with more classes if additional log types (e.g., warning) are needed
    private static string GetLogClass(string status)
    {
        if (status.Contains("Error") || status.Contains("Disconnected")) return "log-error";
        if (status.Contains("joined") || status.Contains("Connected")) return "log-success";
        return "log-info";
    }

    // Action method: Handles joining the chat with username and language
    // Validates inputs and invokes ChatService.JoinChat
    // Maintenance Note: Consider adding client-side validation for language codes or persisting language in local storage for reconnections
    private async Task Join()
    {
        Console.WriteLine($"Join method entered, currentUser = '{_currentUser}', language = '{_selectedLanguage}'");
        if (!string.IsNullOrWhiteSpace(_currentUser) && _selectedLanguage != null)
        {
            Console.WriteLine($"Join clicked for {_currentUser} with language {_selectedLanguage}");
            await ChatService.JoinChat(_currentUser, _selectedLanguage); // Pass language to service
            Console.WriteLine("JoinChat completed");
            _isJoined = true;
        }
    }

    // Action method: Sends a general message
    // Clears input field after sending
    private async Task Send()
    {
        if (!string.IsNullOrWhiteSpace(_message))
        {
            await ChatService.SendMessage(_currentUser, _message);
            _message = "";
        }
    }

    // Action method: Joins a group
    // Updates selected group if necessary
    private async Task JoinGroup()
    {
        if (!string.IsNullOrWhiteSpace(_groupName))
        {
            await ChatService.JoinGroup(_groupName);
            if (_selectedGroup == null && ChatService.JoinedGroups.Contains(_groupName))
            {
                _selectedGroup = _groupName;
            }
            _groupName = "";
        }
    }

    // Action method: Leaves a group
    // Updates status log and resets selected group if needed
    private async Task LeaveGroup()
    {
        if (!string.IsNullOrWhiteSpace(_groupName))
        {
            await ChatService.LeaveGroup(_groupName);
            _statusMessages.Add(new StatusEntry($"{_currentUser} left group {_groupName}"));
            if (_selectedGroup == _groupName)
            {
                _selectedGroup = ChatService.JoinedGroups.FirstOrDefault();
            }
            _groupName = "";
            StateHasChanged();
            await ScrollLogToBottom();
        }
    }

    // Action method: Sends a message to the selected group
    private async Task SendGroup()
    {
        if (!string.IsNullOrWhiteSpace(_groupMessage) && !string.IsNullOrEmpty(_selectedGroup))
        {
            await ChatService.SendGroupMessage(_selectedGroup, _groupMessage);
            _groupMessage = "";
        }
    }

    // Action method: Sends a private message
    // Resets selected user after sending
    private async Task SendPrivate()
    {
        if (!string.IsNullOrWhiteSpace(_privateMessage) && !string.IsNullOrEmpty(_selectedUser))
        {
            Console.WriteLine($"Sending private message to {_selectedUser}: {_privateMessage}");
            await ChatService.SendPrivateMessage(_selectedUser, _privateMessage);
            _privateMessage = "";
            _selectedUser = null; // Reset to force re-selection
        }
    }

    // Action method: Leaves the chat
    // Resets all state fields
    private async Task Leave()
    {
        await ChatService.LeaveChat(_currentUser);
        _currentUser = "";
        _groupName = "";
        _selectedGroup = null;
        _selectedUser = null;
        _isJoined = false;
        StateHasChanged();
    }
}

<style>
    .chat-container {
        display: flex;
        flex-direction: column;
        gap: 20px;
    }

    .chat-section {
        background-color: #fff;
        border: 1px solid #ddd;
        padding: 10px;
        border-radius: 5px;
    }

    .message-list {
        max-height: 200px;
        overflow-y: auto;
        margin-bottom: 10px;
    }

    .input-group {
        display: flex;
        gap: 10px;
        align-items: center;
    }

    .input-field {
        flex: 1;
        padding: 5px;
        border: 1px solid #ddd;
        border-radius: 3px;
    }

    .group-join-section {
        background-color: #f8f9fa;
        border: 1px solid #ddd;
        padding: 10px;
        border-radius: 5px;
    }

    .group-controls {
        display: flex;
        gap: 10px;
        margin-bottom: 10px;
    }

    .group-select, .user-select {
        margin-bottom: 10px;
        display: flex;
        align-items: center;
    }

        .group-select label, .user-select label {
            margin-right: 10px;
        }

        .group-select select, .user-select select {
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }

    .log-window {
        width: 100%;
        max-width: 400px;
        background-color: #f8f9fa;
        border: 1px solid #ddd;
        padding: 10px;
        border-radius: 5px;
    }

    .log-list {
        max-height: 150px;
        overflow-y: auto;
        font-size: 12px;
        background-color: #fff;
        padding: 5px;
        border: 1px solid #eee;
    }

        .log-list p {
            margin: 2px 0;
            padding: 5px;
            border-radius: 3px;
        }

    .log-error {
        background-color: #f8d7da;
        color: #721c24;
    }

    .log-success {
        background-color: #d4edda;
        color: #155724;
    }

    .log-info {
        background-color: #cce5ff;
        color: #004085;
    }

    .btn {
        padding: 5px 10px;
        border-radius: 3px;
    }

    .btn-primary {
        background-color: #007bff;
        color: #fff;
    }

    .btn-success {
        background-color: #28a745;
        color: #fff;
    }

    .btn-warning {
        background-color: #ffc107;
        color: #212529;
    }

    .btn-danger {
        background-color: #dc3545;
        color: #fff;
    }
</style>