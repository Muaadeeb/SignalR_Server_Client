@page "/chat"
@using SignalR.Client.Services.Interfaces
@inject IChatService ChatService
@inject IJSRuntime JsRuntime

@* 
    Comment Section: StateHasChanged, ScrollLogToBottom, and Related Patterns

    1. StateHasChanged()
    - Use Case: Notifies Blazor that the component's state has changed, triggering a synchronous render on the current thread.
    - When Used: In action methods (e.g., Leave(), LeaveGroup()) after updating state (e.g., _statusMessages, _currentUser) to refresh 
        the UI immediately.
    - Why: Simple, synchronous, and safe in WebAssembly mode (single-threaded) when called post-await or in user-triggered 
        events (e.g., button clicks). Avoids overhead of InvokeAsync when already on the UI thread.

    2. ScrollLogToBottom()
    - Use Case: Scrolls the activity log (<div class="log-list">) to the bottom using JS interop (JSRuntime.InvokeVoidAsync).
    - When Used: In action methods (e.g., LeaveGroup()) after state updates to ensure the latest log entry is visible.
    - Why: Async method due to JS interop; must be awaited to ensure scrolling happens after the UI reflects the new state, 
        avoiding race conditions where scroll occurs before render.

    3. await InvokeAsync(StateHasChanged)
    - Use Case: Asynchronously queues a render on the UI thread (synchronization context), ensuring thread safety for SignalR event handlers.
    - When Used: In OnInitializedAsync event handlers (e.g., OnMessageReceived, OnUserJoined) triggered by ChatService SignalR events.
    - Why: SignalR events might fire on background threads (hub connection thread), even in WebAssembly (less common but possible). 
        InvokeAsync ensures UI updates are marshaled to the renderer’s thread, making it robust for potential InteractiveServer mode 
        use (multithreaded circuit).

    4. await ScrollLogToBottom()
    - Use Case: Ensures the JS interop scroll completes before proceeding, used in action methods or deferred via OnAfterRenderAsync.
    - When Used: In LeaveGroup() after StateHasChanged() to scroll post-render, and in OnAfterRenderAsync when deferred from event handlers.
    - Why: Awaited in action methods to maintain order (render, then scroll). Deferred to OnAfterRenderAsync in event handlers to avoid 
        JS interop during prerendering (SSR), which lacks a browser context.

    5. _needsScroll (private bool field)
    - Use Case: Flags when the activity log needs scrolling, set in SignalR event handlers and checked in OnAfterRenderAsync.
    - When Used: In OnInitializedAsync event handlers (e.g., OnUserJoined, OnPrivateMessageReceived) to defer scrolling until post-render.
    - Why: Prevents JS interop errors during prerendering (SSR) when the log-list element isn’t in the DOM yet. Combined with isJoined 
        check in OnAfterRenderAsync, ensures scrolling only happens when the log is visible (isJoined = true).
*@

<div class="chat-container">
    <h3>Chat Room</h3>
    @if (ChatService == null)
    {
        <p>Error: ChatService not available. Please refresh or contact support.</p>
    }
    else
    {
        <p>Debug: IsConnected = @ChatService.IsConnected, CurrentUser = "@_currentUser", IsJoined = @_isJoined</p>
        @if (!ChatService.IsConnected)
        {
            <p class="status">Connecting to chat... <span class="spinner"></span></p>
        }
        else if (!_isJoined)
        {
            <div class="join-section">
                <input @bind="_currentUser" @bind:event="oninput" placeholder="Enter your name" class="input-field" />
                <button @onclick="Join" class="btn btn-primary">Join Chat</button>
            </div>
        }
        else
        {
            <div class="user-info">
                <p>Logged in as: <strong>@_currentUser</strong> (ID: @ChatService.ConnectionId)</p>
                <button @onclick="Leave" class="btn btn-danger">Leave Chat</button>
            </div>

            <!-- General Chat Section -->
            <div class="chat-section">
                <h4>General Chat</h4>
                <div class="message-list">
                    @foreach (var msg in _messages.Where(m => m.StartsWith("[General]")))
                    {
                        <p>@msg</p>
                    }
                </div>
                <div class="input-group">
                    <input @bind="_message" @bind:event="oninput" placeholder="Type a message" class="input-field" />
                    <button @onclick="Send" class="btn btn-primary">Send</button>
                </div>
            </div>

            <!-- Group Chats Section -->
            <div class="chat-section">
                <h4>Group Chats</h4>
                <div class="message-list">
                    @foreach (var msg in _messages.Where(m => m.Contains("[Group")))
                    {
                        <p>@msg</p>
                    }
                </div>
                @if (ChatService.JoinedGroups.Any())
                {
                    <div class="group-select">
                        <label>Select group to send to:</label>
                        <select @bind="_selectedGroup" class="input-field">
                            @foreach (var group in ChatService.JoinedGroups)
                            {
                                <option value="@group">@group</option>
                            }
                        </select>
                    </div>
                }
                <div class="input-group">
                    <input @bind="_groupMessage" @bind:event="oninput" placeholder="Group message" class="input-field" />
                    <button @onclick="SendGroup" class="btn btn-primary" disabled="@(string.IsNullOrEmpty(_selectedGroup))">Send to Group</button>
                </div>
            </div>

            <!-- Private Chats Section -->
            <div class="chat-section">
                <h4>Private Chats</h4>
                <div class="message-list">
                    @foreach (var msg in _privateMessages)
                    {
                        <p>@msg</p>
                    }
                </div>
                @if (_onlineUsers.Any(u => u != _currentUser))
                {
                    <div class="user-select">
                        <label>Select user to message:</label>
                        <select @bind="_selectedUser" class="input-field">
                            @foreach (var user in _onlineUsers.Where(u => u != _currentUser))
                            {
                                <option value="@user">@user</option>
                            }
                        </select>
                    </div>
                }
                <div class="input-group">
                    <input @bind="_privateMessage" @bind:event="oninput" placeholder="Private message" class="input-field" />
                    <button @onclick="SendPrivate" class="btn btn-primary" disabled="@(string.IsNullOrEmpty(_selectedUser))">Send Private</button>
                </div>
            </div>

            <!-- Join/Leave Group Section -->
            <div class="group-join-section">
                <h4>Join/Leave Group</h4>
                <div class="group-controls">
                    <input @bind="_groupName" @bind:event="oninput" placeholder="Group name" class="input-field" />
                    <button @onclick="JoinGroup" class="btn btn-success">Join</button>
                    <button @onclick="LeaveGroup" class="btn btn-warning">Leave</button>
                </div>
                <p>Joined groups: @(ChatService.JoinedGroups.Any() ? string.Join(", ", ChatService.JoinedGroups) : "None")</p>
            </div>

            <!-- Activity Log Section -->
            <div class="log-window">
                <h4>Activity Log</h4>
                <div class="log-list" @ref="_logList">
                    @foreach (var entry in _statusMessages)
                    {
                        <p @key="entry.Timestamp.Ticks" class="@GetLogClass(entry.Message)">
                            @entry.Timestamp.ToString("HH:mm:ss") - @entry.Message
                        </p>
                    }
                </div>
            </div>
        }
    }
</div>

<script>
    window.scrollToBottom = (element) => {
        element.scrollTop = element.scrollHeight;
    };
</script>

@code {
    private string _currentUser = "";
    private string _message = "";
    private string _groupName = "";
    private string _groupMessage = "";
    private string _privateMessage = "";
    private string? _selectedGroup = null;
    private string? _selectedUser = null;
    private readonly List<string> _messages = [];
    private readonly List<string> _privateMessages = [];
    private List<string> _onlineUsers = new();
    private readonly List<StatusEntry> _statusMessages = [];
    private bool _isJoined = false;
    private ElementReference _logList;
    private bool _needsScroll = false; // Add this field at the class level

    private class StatusEntry(string message)
    {
        public DateTime Timestamp { get; set; } = DateTime.Now;
        public string Message { get; set; } = message;
    }

    protected override async Task OnInitializedAsync()
    {
        if (ChatService == null)
        {
            Console.WriteLine("ChatService is null on initialization!");
            _statusMessages.Add(new StatusEntry("Error: ChatService not injected"));
            StateHasChanged(); // Keep as is
            return;
        }

        Console.WriteLine("Chat page initialized, starting SignalR connection...");
        try
        {
            await ChatService.StartConnectionAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to start SignalR connection: {ex.Message}");
            _statusMessages.Add(new StatusEntry($"Error starting connection: {ex.Message}"));
            StateHasChanged(); // Keep as is
        }

        ChatService.OnMessageReceived += async (user, msg) =>
        {
            _messages.Add($"[General] {user}: {msg}");
            Console.WriteLine($"General message added: [General] {user}: {msg}");
            await InvokeAsync(StateHasChanged);
        };

        ChatService.OnGroupMessageReceived += async (user, msg) =>
        {
            var parts = msg.Split('|', 2);

            if (parts.Length != 2) return;

            var groupName = parts[0];
            var messageText = parts[1];

            if (!ChatService.JoinedGroups.Contains(groupName)) return;

            var formattedMsg = $"[Group:{groupName}] {user}: {messageText}";
            _messages.Add(formattedMsg);

            Console.WriteLine($"Group message added: {formattedMsg}");
            await InvokeAsync(StateHasChanged);
        };

        ChatService.OnUserJoined += async (user) =>
        {
            _statusMessages.Add(new StatusEntry($"{user} joined the chat"));
            await InvokeAsync(StateHasChanged);
            _needsScroll = true; // Flag for scrolling
        };

        ChatService.OnUserLeft += async (user) =>
        {
            _statusMessages.Add(new StatusEntry($"{user} left the chat"));
            await InvokeAsync(StateHasChanged);
            _needsScroll = true;
        };

        ChatService.OnUserListUpdated += async (users) =>
        {
            _onlineUsers = users;
            if (_selectedUser == null || !_onlineUsers.Contains(_selectedUser))
            {
                _selectedUser = _onlineUsers.FirstOrDefault(u => u != _currentUser);
            }
            await InvokeAsync(StateHasChanged);
        };

        ChatService.OnGroupMessage += async (msg) =>
        {
            _statusMessages.Add(new StatusEntry(msg));
            await InvokeAsync(StateHasChanged);
            _needsScroll = true;
        };

        ChatService.OnConnected += async () =>
        {
            _statusMessages.Add(new StatusEntry("Connected to the server"));
            await InvokeAsync(StateHasChanged);
            _needsScroll = true;
        };

        ChatService.OnDisconnected += async () =>
        {
            _statusMessages.Add(new StatusEntry("Disconnected from the server"));
            _onlineUsers.Clear();
            _isJoined = false;
            await InvokeAsync(StateHasChanged);
            _needsScroll = true;
        };

        ChatService.OnReconnecting += async () =>
        {
            _statusMessages.Add(new StatusEntry("Reconnecting..."));
            await InvokeAsync(StateHasChanged);
            _needsScroll = true;
        };

        ChatService.OnReconnected += async () =>
        {
            _statusMessages.Add(new StatusEntry("Reconnected!"));
            _selectedGroup = null;
            _selectedUser = null;
            await InvokeAsync(StateHasChanged);
            _needsScroll = true;
        };

        ChatService.OnError += async (error) =>
        {
            _statusMessages.Add(new StatusEntry($"Error: {error}"));
            await InvokeAsync(StateHasChanged);
            _needsScroll = true;
        };

        ChatService.OnPrivateMessageReceived += async (fromUser, msg) =>
        {
            if (fromUser != _currentUser)
            {
                _privateMessages.Add($"[Private] {fromUser}: {msg}");
            }
            _statusMessages.Add(new StatusEntry($"Private message from {fromUser}: {msg}"));
            Console.WriteLine($"Private message received: [Private] {fromUser} to {_currentUser}: {msg}");
            await InvokeAsync(StateHasChanged);
            _needsScroll = true;
        };
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        Console.WriteLine($"Chat.razor rendered, firstRender: {firstRender}");
        if (_needsScroll && ChatService != null && _isJoined)
        {
            await ScrollLogToBottom();
            _needsScroll = false;
        }
        await base.OnAfterRenderAsync(firstRender);
    }

    private async Task ScrollLogToBottom()
    {
        await JsRuntime.InvokeVoidAsync("scrollToBottom", _logList);
    }

    private static string GetLogClass(string status)
    {
        if (status.Contains("Error") || status.Contains("Disconnected")) return "log-error";
        if (status.Contains("joined") || status.Contains("Connected")) return "log-success";
        return "log-info";
    }

    private async Task Join()
    {
        Console.WriteLine($"Join method entered, currentUser = '{_currentUser}'");
        if (!string.IsNullOrWhiteSpace(_currentUser))
        {
            Console.WriteLine($"Join clicked for {_currentUser}");
            await ChatService.JoinChat(_currentUser);
            Console.WriteLine("JoinChat completed");
            _isJoined = true;
        }
    }

    private async Task Send()
    {
        if (!string.IsNullOrWhiteSpace(_message))
        {
            await ChatService.SendMessage(_currentUser, _message);
            _message = "";
        }
    }

    private async Task JoinGroup()
    {
        if (!string.IsNullOrWhiteSpace(_groupName))
        {
            await ChatService.JoinGroup(_groupName);
            if (_selectedGroup == null && ChatService.JoinedGroups.Contains(_groupName))
            {
                _selectedGroup = _groupName;
            }
            _groupName = "";
        }
    }

    private async Task LeaveGroup()
    {
        if (!string.IsNullOrWhiteSpace(_groupName))
        {
            await ChatService.LeaveGroup(_groupName);
            _statusMessages.Add(new StatusEntry($"{_currentUser} left group {_groupName}"));
            if (_selectedGroup == _groupName)
            {
                _selectedGroup = ChatService.JoinedGroups.FirstOrDefault();
            }
            _groupName = "";
            StateHasChanged();
            await ScrollLogToBottom();
        }
    }

    private async Task SendGroup()
    {
        if (!string.IsNullOrWhiteSpace(_groupMessage) && !string.IsNullOrEmpty(_selectedGroup))
        {
            await ChatService.SendGroupMessage(_selectedGroup, _groupMessage);
            _groupMessage = "";
        }
    }

    private async Task SendPrivate()
    {
        if (!string.IsNullOrWhiteSpace(_privateMessage) && !string.IsNullOrEmpty(_selectedUser))
        {
            await ChatService.SendPrivateMessage(_selectedUser, _privateMessage);
            _privateMessage = "";
        }
    }

    private async Task Leave()
    {
        await ChatService.LeaveChat(_currentUser);
        _currentUser = "";
        _groupName = "";
        _selectedGroup = null;
        _selectedUser = null;
        _isJoined = false;
        StateHasChanged();
    }
}

<style>
    .chat-container {
        display: flex;
        flex-direction: column;
        gap: 20px;
    }

    .chat-section {
        background-color: #fff;
        border: 1px solid #ddd;
        padding: 10px;
        border-radius: 5px;
    }

    .message-list {
        max-height: 200px;
        overflow-y: auto;
        margin-bottom: 10px;
    }

    .input-group {
        display: flex;
        gap: 10px;
        align-items: center;
    }

    .input-field {
        flex: 1;
        padding: 5px;
        border: 1px solid #ddd;
        border-radius: 3px;
    }

    .group-join-section {
        background-color: #f8f9fa;
        border: 1px solid #ddd;
        padding: 10px;
        border-radius: 5px;
    }

    .group-controls {
        display: flex;
        gap: 10px;
        margin-bottom: 10px;
    }

    .group-select, .user-select {
        margin-bottom: 10px;
        display: flex;
        align-items: center;
    }

    .group-select label, .user-select label {
        margin-right: 10px;
    }

    .group-select select, .user-select select {
        padding: 5px;
        border: 1px solid #ddd;
        border-radius: 3px;
    }

    .log-window {
        width: 100%;
        max-width: 400px;
        background-color: #f8f9fa;
        border: 1px solid #ddd;
        padding: 10px;
        border-radius: 5px;
    }

    .log-list {
        max-height: 150px;
        overflow-y: auto;
        font-size: 12px;
        background-color: #fff;
        padding: 5px;
        border: 1px solid #eee;
    }

    .log-list p {
        margin: 2px 0;
        padding: 5px;
        border-radius: 3px;
    }

    .log-error {
        background-color: #f8d7da;
        color: #721c24;
    }

    .log-success {
        background-color: #d4edda;
        color: #155724;
    }

    .log-info {
        background-color: #cce5ff;
        color: #004085;
    }

    .btn {
        padding: 5px 10px;
        border-radius: 3px;
    }

    .btn-primary {
        background-color: #007bff;
        color: #fff;
    }

    .btn-success {
        background-color: #28a745;
        color: #fff;
    }

    .btn-warning {
        background-color: #ffc107;
        color: #212529;
    }

    .btn-danger {
        background-color: #dc3545;
        color: #fff;
    }
</style>