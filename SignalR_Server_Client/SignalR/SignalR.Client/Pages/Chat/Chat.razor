@* 
    Comment Section: StateHasChanged, ScrollLogToBottom, and Related Patterns

    1. StateHasChanged()
    - Use Case: Notifies Blazor that the component's state has changed, triggering a synchronous render on the current thread.
    - When Used: In action methods (e.g., Leave(), LeaveGroup()) after updating state (e.g., _statusMessages, _currentUser) to refresh 
        the UI immediately.
    - Why: Simple, synchronous, and safe in WebAssembly mode (single-threaded) when called post-await or in user-triggered 
        events (e.g., button clicks). Avoids overhead of InvokeAsync when already on the UI thread.

    2. ScrollLogToBottom()
    - Use Case: Scrolls the activity log (<div class="log-list">) to the bottom using JS interop (JSRuntime.InvokeVoidAsync).
    - When Used: In action methods (e.g., LeaveGroup()) after state updates to ensure the latest log entry is visible.
    - Why: Async method due to JS interop; must be awaited to ensure scrolling happens after the UI reflects the new state, 
        avoiding race conditions where scroll occurs before render.

    3. await InvokeAsync(StateHasChanged)
    - Use Case: Asynchronously queues a render on the UI thread (synchronization context), ensuring thread safety for SignalR event handlers.
    - When Used: In OnInitializedAsync event handlers (e.g., OnMessageReceived, OnUserJoined) triggered by ChatService SignalR events.
    - Why: SignalR events might fire on background threads (hub connection thread), even in WebAssembly (less common but possible). 
        InvokeAsync ensures UI updates are marshaled to the renderer’s thread, making it robust for potential InteractiveServer mode 
        use (multithreaded circuit).

    4. await ScrollLogToBottom()
    - Use Case: Ensures the JS interop scroll completes before proceeding, used in action methods or deferred via OnAfterRenderAsync.
    - When Used: In LeaveGroup() after StateHasChanged() to scroll post-render, and in OnAfterRenderAsync when deferred from event handlers.
    - Why: Awaited in action methods to maintain order (render, then scroll). Deferred to OnAfterRenderAsync in event handlers to avoid 
        JS interop during prerendering (SSR), which lacks a browser context.

    5. _needsScroll (private bool field)
    - Use Case: Flags when the activity log needs scrolling, set in SignalR event handlers and checked in OnAfterRenderAsync.
    - When Used: In OnInitializedAsync event handlers (e.g., OnUserJoined, OnPrivateMessageReceived) to defer scrolling until post-render.
    - Why: Prevents JS interop errors during prerendering (SSR) when the log-list element isn’t in the DOM yet. Combined with isJoined 
        check in OnAfterRenderAsync, ensures scrolling only happens when the log is visible (isJoined = true).
*@

@page "/chat"
@using SignalR.Client.Pages.Chat.Components
@using SignalR.Client.Services.Interfaces
@using SignalR.Client.Shared.Models

@inject IChatService ChatService
@inject IJSRuntime JsRuntime

<div class="chat-container">
    <h3>Chat Room</h3>
    @if (ChatService == null)
    {
        <p>Error: ChatService not available. Please refresh or contact support.</p>
    }
    else
    {
        <p>Debug: IsConnected = @ChatService.IsConnected, CurrentUser = "@_currentUser", IsJoined = @_isJoined</p>
        @if (!ChatService.IsConnected)
        {
            <p class="status">Connecting to chat... <span class="spinner"></span></p>
        }
        else if (!_isJoined)
        {
            <ChatJoin @bind-User="_currentUser"
                      @bind-Language="_selectedLanguage"
                      OnJoin="Join" />
        }
        else
        {
            <ChatUserInfo User=@_currentUser
                          Language=@_selectedLanguage
                          ConnectionId=@ChatService.ConnectionId
                          OnLeave="Leave" />
            
            <ChatGeneral Messages="_messages"
                         @bind-Message="_message"
                         OnSend="HandleSendGeneral" />

            <ChatGroupJoin @bind-GroupName="_groupName"
                           JoinedGroups="ChatService.JoinedGroups"
                           OnJoin="JoinGroup"
                           OnLeave="LeaveGroup" />

            <ChatGroups Messages="_messages"
                        JoinedGroups="ChatService.JoinedGroups"
                        @bind-SelectedGroup="_selectedGroup"
                        @bind-GroupMessage="_groupMessage"
                        OnSend="HandleSendGroup" />
            
            <ChatPrivate Messages="_privateMessages"
                         OnlineUsers="_onlineUsers.Distinct().Where(u => u != _currentUser).ToList()"
                         CurrentUser="_currentUser"
                         @bind-SelectedUser="_selectedUser"
                         @bind-PrivateMessage="_privateMessage"
                         OnSend="HandleSendPrivate" />

            <ChatLog LogEntries="_statusMessages.ToList()"
                     LogListRef="_logList"
                     GetLogClass="GetLogClass" />
        }
    }
</div>

<script>
    window.scrollToBottom = (element) => {
        element.scrollTop = element.scrollHeight;
    };
</script>

@code {
    private string _currentUser = "";
    private string _message = "";
    private string _groupName = "";
    private string _groupMessage = "";
    private string _privateMessage = "";
    private string? _selectedGroup = null;
    private string? _selectedUser = null;
    private string? _selectedLanguage = "en";
    private readonly List<ChatMessageDto> _messages = new();
    private readonly List<ChatMessageDto> _privateMessages = new();
    private List<string> _onlineUsers = new();
    private readonly List<StatusEntry> _statusMessages = new();
    private bool _isJoined = false;
    private ElementReference _logList;
    private bool _needsScroll = false;

    protected override async Task OnInitializedAsync()  
    {
        if (ChatService == null)
        {
            _statusMessages.Add(new StatusEntry("Error: ChatService not injected"));
            StateHasChanged();
            return;
        }

        try
        {
            await ChatService.StartConnectionAsync();
        }
        catch (Exception ex)
        {
            _statusMessages.Add(new StatusEntry($"Error starting connection: {ex.Message}"));
            StateHasChanged();
        }

        ChatService.OnMessageReceived += async (msg) =>
        {
            _messages.Add(msg);
            await InvokeAsync(StateHasChanged);
            _needsScroll = true;
        };

        ChatService.OnGroupMessageReceived += async (msg) =>
        {
            if (!string.IsNullOrEmpty(msg.Group) && ChatService.JoinedGroups.Contains(msg.Group))
            {
                _messages.Add(msg);
                await InvokeAsync(StateHasChanged);
                _needsScroll = true;
            }
        };

        ChatService.OnPrivateMessageReceived += async (msg) =>
        {
            _privateMessages.Add(msg);
            _statusMessages.Add(new StatusEntry($"Private message from {msg.User ?? "?"}: {msg.Message ?? ""}"));
            await InvokeAsync(StateHasChanged);
            _needsScroll = true;
        };

        ChatService.OnUserJoined += async (user) =>
        {
            _statusMessages.Add(new StatusEntry($"{user} joined the chat"));
            await InvokeAsync(StateHasChanged);
            _needsScroll = true;
        };

        ChatService.OnUserLeft += async (user) =>
        {
            _statusMessages.Add(new StatusEntry($"{user} left the chat"));
            await InvokeAsync(StateHasChanged);
            _needsScroll = true;
        };

        ChatService.OnUserListUpdated += async (users) =>
        {
            _onlineUsers = users;
            if (_selectedUser != null && !_onlineUsers.Contains(_selectedUser))
            {
                _selectedUser = null;
            }
            await InvokeAsync(StateHasChanged);
        };

        ChatService.OnGroupMessage += async (msg) =>
        {
            _statusMessages.Add(new StatusEntry(msg));
            await InvokeAsync(StateHasChanged);
            _needsScroll = true;
        };

        ChatService.OnConnected += async () =>
        {
            _statusMessages.Add(new StatusEntry("Connected to the server"));
            _isJoined = true; // Defensive: set joined on connect
            await InvokeAsync(StateHasChanged);
            _needsScroll = true;
        };

        ChatService.OnDisconnected += async () =>
        {
            _statusMessages.Add(new StatusEntry("Disconnected from the server"));
            _onlineUsers.Clear();
            _isJoined = false;
            await InvokeAsync(StateHasChanged);
            _needsScroll = true;
        };

        ChatService.OnReconnecting += async () =>
        {
            _statusMessages.Add(new StatusEntry("Reconnecting..."));
            await InvokeAsync(StateHasChanged);
            _needsScroll = true;
        };

        ChatService.OnReconnected += async () =>
        {
            _statusMessages.Add(new StatusEntry("Reconnected!"));
            _selectedGroup = null;
            _selectedUser = null;
            _isJoined = true; // Defensive: set joined on reconnect
            await InvokeAsync(StateHasChanged);
            _needsScroll = true;
        };

        ChatService.OnError += async (error) =>
        {
            _statusMessages.Add(new StatusEntry($"Error: {error}"));
            await InvokeAsync(StateHasChanged);
            _needsScroll = true;
        };
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_needsScroll && ChatService != null && _isJoined)
        {
            await ScrollLogToBottom();
            _needsScroll = false;
        }
        await base.OnAfterRenderAsync(firstRender);
    }

    private async Task ScrollLogToBottom()
    {
        await JsRuntime.InvokeVoidAsync("scrollToBottom", _logList);
    }

    private static string GetLogClass(string status)
    {
        if (status.Contains("Error") || status.Contains("Disconnected")) return "log-error";
        if (status.Contains("joined") || status.Contains("Connected")) return "log-success";
        return "log-info";
    }

    private async Task Join()
    {
        if (!string.IsNullOrWhiteSpace(_currentUser) && _selectedLanguage != null)
        {
            try
            {
                await ChatService.JoinChat(_currentUser, _selectedLanguage);
                _isJoined = true;
                StateHasChanged();
            }
            catch (Exception ex)
            {
                _statusMessages.Add(new StatusEntry($"Join failed: {ex.Message}"));
                StateHasChanged();
            }
        }
    }

    private async Task Send()
    {
        if (!string.IsNullOrWhiteSpace(_message))
        {
            await ChatService.SendMessage(_currentUser, _message);
            _message = "";
        }
    }

    private async Task JoinGroup()
    {
        if (!string.IsNullOrWhiteSpace(_groupName))
        {
            await ChatService.JoinGroup(_groupName);
            if (_selectedGroup == null && ChatService.JoinedGroups.Contains(_groupName))
            {
                _selectedGroup = _groupName;
            }
            _groupName = "";
        }
    }

    private async Task LeaveGroup()
    {
        if (!string.IsNullOrWhiteSpace(_groupName))
        {
            await ChatService.LeaveGroup(_groupName);
            _statusMessages.Add(new StatusEntry($"{_currentUser} left group {_groupName}"));
            if (_selectedGroup == _groupName)
            {
                _selectedGroup = ChatService.JoinedGroups.FirstOrDefault();
            }
            _groupName = "";
            StateHasChanged();
            await ScrollLogToBottom();
        }
    }

    private async Task SendGroup()
    {
        if (!string.IsNullOrWhiteSpace(_groupMessage) && !string.IsNullOrEmpty(_selectedGroup))
        {
            await ChatService.SendGroupMessage(_selectedGroup, _groupMessage);
            _groupMessage = "";
        }
    }

    private async Task SendPrivate()
    {
        if (!string.IsNullOrWhiteSpace(_privateMessage) && !string.IsNullOrEmpty(_selectedUser))
        {
            await ChatService.SendPrivateMessage(_selectedUser, _privateMessage);
            _privateMessage = "";
            _selectedUser = null;
        }
    }

    private async Task HandleSendGeneral(string message)
    {
        await ChatService.SendMessage(_currentUser, message);
        _message = "";
    }

    private async Task HandleSendGroup((string Group, string Message) data)
    {
        await ChatService.SendGroupMessage(data.Group, data.Message);
        _groupMessage = "";

    }

    private async Task HandleSendPrivate((string ToUser, string Message) data)
    {
        await ChatService.SendPrivateMessage(data.ToUser, data.Message);
        _privateMessage = "";
        _selectedUser = null;
    }

    private async Task Leave()
    {
        await ChatService.LeaveChat(_currentUser);
        _currentUser = "";
        _groupName = "";
        _selectedGroup = null;
        _selectedUser = null;
        _isJoined = false;
        StateHasChanged();
    }
}

<style>
    .chat-container {
        display: flex;
        flex-direction: column;
        gap: 20px;
    }

    .chat-section {
        background-color: #fff;
        border: 1px solid #ddd;
        padding: 10px;
        border-radius: 5px;
    }

    .message-list {
        max-height: 200px;
        overflow-y: auto;
        margin-bottom: 10px;
    }

    .input-group {
        display: flex;
        gap: 10px;
        align-items: center;
    }

    .input-field {
        flex: 1;
        padding: 5px;
        border: 1px solid #ddd;
        border-radius: 3px;
    }

    .group-join-section {
        background-color: #f8f9fa;
        border: 1px solid #ddd;
        padding: 10px;
        border-radius: 5px;
    }

    .group-controls {
        display: flex;
        gap: 10px;
        margin-bottom: 10px;
    }

    .group-select, .user-select {
        margin-bottom: 10px;
        display: flex;
        align-items: center;
    }

        .group-select label, .user-select label {
            margin-right: 10px;
        }

        .group-select select, .user-select select {
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }

    .log-window {
        width: 100%;
        max-width: 400px;
        background-color: #f8f9fa;
        border: 1px solid #ddd;
        padding: 10px;
        border-radius: 5px;
    }

    .log-list {
        max-height: 150px;
        overflow-y: auto;
        font-size: 12px;
        background-color: #fff;
        padding: 5px;
        border: 1px solid #eee;
    }

        .log-list p {
            margin: 2px 0;
            padding: 5px;
            border-radius: 3px;
        }

    .log-error {
        background-color: #f8d7da;
        color: #721c24;
    }

    .log-success {
        background-color: #d4edda;
        color: #155724;
    }

    .log-info {
        background-color: #cce5ff;
        color: #004085;
    }

    .btn {
        padding: 5px 10px;
        border-radius: 3px;
    }

    .btn-primary {
        background-color: #007bff;
        color: #fff;
    }

    .btn-success {
        background-color: #28a745;
        color: #fff;
    }

    .btn-warning {
        background-color: #ffc107;
        color: #212529;
    }

    .btn-danger {
        background-color: #dc3545;
        color: #fff;
    }
</style>